1. What is Variable Shadowing?
--local variable hides the instance variables inside that scope and takes precedence

â€ƒâ€ƒpublic class MyClass {
â€ƒâ€ƒâ€ƒâ€ƒprivate String name;
â€ƒâ€ƒâ€ƒâ€ƒprivate int age;

â€ƒâ€ƒâ€ƒâ€ƒpublic MyClass(String name, int age) {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒname = name;
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒage = age;
â€ƒâ€ƒâ€ƒâ€ƒ}

â€ƒâ€ƒâ€ƒâ€ƒvoid myMethod() {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒSystem.out.println("name : " + name + " and age : " + age);
â€ƒâ€ƒâ€ƒâ€ƒ}

â€ƒâ€ƒâ€ƒâ€ƒpublic static void main(String[] args) {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒMyClass myObj = new MyClass("xyz", 25);
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒmyObj.myMethod();
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}
>> name : null and age : 0


2. What will be the output of the following snippet
â€ƒâ€ƒâ€ƒâ€ƒint a=5, b=5, c=7;
 Â Â Â Â Â Â  if(a>b++ && a<c++){
 Â Â Â Â Â Â Â Â Â Â  System.out.println("IF: "+a+"&"+b+"&"+c);
 Â Â Â Â Â Â  }else{
 Â Â Â Â Â Â Â Â Â Â  System.out.println("ELSE: "+a+"&"+b+"&"+c);
 Â Â Â Â Â Â  }
>> ELSE: 5&6&7



3.Â  Whats the difference between heap memory and String pool memory?Â 
What will be the output of the below?
public class Test {
 Â Â  public static void main(String[] args) {
 Â Â Â Â Â Â  String s1 = "Java";
 Â Â Â Â Â Â  String s2 = new String("Java");
 Â Â Â Â Â Â  String s3 = s2.intern();
â€ƒâ€ƒ
 Â Â Â Â Â Â  System.out.println(s1 == s2); // Line 1
 Â Â Â Â Â Â  System.out.println(s1 == s3); // Line 2
â€ƒâ€ƒâ€ƒâ€ƒ
â€ƒâ€ƒâ€ƒâ€ƒString s4 = "Ja"+"va";
â€ƒâ€ƒâ€ƒâ€ƒString s5 = "Ja";
â€ƒâ€ƒâ€ƒâ€ƒString s6 = s5 + "va";
â€ƒâ€ƒâ€ƒâ€ƒ
â€ƒâ€ƒâ€ƒâ€ƒSystem.out.println(s1 == s4); // Line 3
 Â Â Â Â Â Â  System.out.println(s1 == s6); // Line 4
 Â Â  }
}
>> Line-1 : False
>> Line-2 : True
>> Line-3 : True
>> Line-4 : False





4. In java every class implicitly extends the Object class, making Object class the ultimate parent of all classes. However java does not support multiple inheritance.
â€ƒâ€ƒclass A{
â€ƒâ€ƒâ€ƒâ€ƒ// A implicitly inherits from Object
â€ƒâ€ƒ}
â€ƒâ€ƒ
â€ƒâ€ƒclass B extends A{
â€ƒâ€ƒâ€ƒâ€ƒ// B inherits from A , and A ultimately iherits from Object
â€ƒâ€ƒ}
In this scenario:
q1. Does class B exhibit multiple inheritance?Â  why or why not
-- No, B does not exhibit multiople inheritance. In java a class can have only one direct superclass. B extends A, and A extends Object, maintainig single inheritance chain
q2. If class A overrides the toString() method from Object, which versio n will class B inherits
-- Class B will inherit the overridden toString() method from A because method resolution follows the inheritance hierarchy



5. Can an Abstract calss be instantiated? (NO)
 Â  Can an Abstract calss have a constuctor? (Yes)Â 
 Â  Why Costructor then if we can not instantiate? (It helps in initialize common properties that all subclass will inherit)
Will this code compile? If yes, what will be the output
â€ƒâ€ƒabstarct class A {
â€ƒâ€ƒâ€ƒâ€ƒpublic A() {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒSystem.out.println("Abstract class Constuctor");
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}
â€ƒâ€ƒ
â€ƒâ€ƒclass B extends A {
â€ƒâ€ƒâ€ƒâ€ƒpublic B() {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒSystem.out.println("Subclass Constructor");
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}
â€ƒâ€ƒ
â€ƒâ€ƒpublic static void main(String[] args) {
 Â Â Â Â Â Â  B obj = new B();
â€ƒâ€ƒ}
â€ƒâ€ƒ
-- Abstract class Constuctor
 Â  CSubclass Constructor
 Â  
6. What will be the output?
â€ƒâ€ƒinterface A{
â€ƒâ€ƒâ€ƒâ€ƒint x = 10;
â€ƒâ€ƒ}



â€ƒâ€ƒclass B implements A{
â€ƒâ€ƒâ€ƒâ€ƒvoid show(){
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒx = 20;
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒSystem.out.println(x);
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒâ€ƒâ€ƒ
â€ƒâ€ƒâ€ƒâ€ƒ public static void main(String[] args) {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒB obj = new B();
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒobj.show();
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}â€ƒâ€ƒ



-- Compilation error as all variables in an interface are public static final by default.



7. What will be the output
â€ƒâ€ƒpublic class MyClass{
 Â Â  staticÂ  int myMethod(){
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒtry{
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒreturn 10;
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒ}finally {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒreturn 20;
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒâ€ƒâ€ƒpublic static void main(String[] args) {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒSystem.out.println(myMethod());
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}
â€ƒâ€ƒ
-- 20



8. which exception propagtes from the below code snippetÂ 
â€ƒâ€ƒstatic void myMethod(){
 Â Â Â Â Â Â  try{
 Â Â Â Â Â Â Â Â Â Â  throw new RuntimeException("exception from try");
 Â Â Â Â Â Â  }catch (Exception e) {
 Â Â Â Â Â Â Â Â Â Â  throw new RuntimeException("exception from catch");
 Â Â Â Â Â Â  }finally {
 Â Â Â Â Â Â Â Â Â Â  throwÂ  new RuntimeException("exception from finally");
 Â Â Â Â Â Â  }
 Â Â  }



-- Exception thrown in finally overides the original exception



9. Difference Between Comparable and Comparator in Java
Feature â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒComparable[java.lang] â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒComparator[java.util]
Definition â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒUsed to define natural ordering of objects. â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒUsed to define custom ordering of objects.
Method â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒcompareTo(T obj) â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒcompare(T obj1, T obj2)
Method â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒReturns 0 (equal), < 0 (less than), > 0 (greater than) â€ƒâ€ƒSame as compareTo()
Modifies Original Class? â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒYes, must implement Comparable<T> inside the class. â€ƒâ€ƒNo, implements Comparator<T> externally.
Sorting Flexibility â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒOnly one sorting order.â€ƒâ€ƒ â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒMultiple sorting orders possible.
Example Usage â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒCollections.sort(list)(if class implements Comparable)Â  Collections.sort(list, comparator) (uses Comparator).
  
10. What will be the output of the below program
â€ƒâ€ƒclass D implements Comparable<D> {
â€ƒâ€ƒâ€ƒâ€ƒint x;
â€ƒâ€ƒÂ 
â€ƒâ€ƒâ€ƒâ€ƒD(int x) {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒthis.x = x;
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒÂ 
â€ƒâ€ƒâ€ƒâ€ƒpublic int compareTo(D d) {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒreturn this.x - d.x;
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}
â€ƒâ€ƒÂ 
â€ƒâ€ƒpublic class Test {
â€ƒâ€ƒâ€ƒâ€ƒpublic static void main(String[] args) {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒList<D> list = new ArrayList<>();
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒlist.add(new D(2));
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒlist.add(null);
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒlist.add(new D(1));
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒ
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒCollections.sort(list);
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒSystem.out.println(list);
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}
â€ƒâ€ƒ
-- null can not be sorted using comparable -- above code gives null pointer exception

11.Â 
â€ƒâ€ƒclass MyClass {
â€ƒâ€ƒâ€ƒâ€ƒint id;
â€ƒâ€ƒâ€ƒâ€ƒ
â€ƒâ€ƒâ€ƒâ€ƒMyClass(int id) { this.id = id; }
â€ƒâ€ƒâ€ƒâ€ƒ
â€ƒâ€ƒâ€ƒâ€ƒpublic int hashCode() { return id; }
â€ƒâ€ƒâ€ƒâ€ƒ
â€ƒâ€ƒâ€ƒâ€ƒpublic boolean equals(Object obj) { return ((MyClass)obj).id == this.id; }
â€ƒâ€ƒ}
â€ƒâ€ƒÂ 
â€ƒâ€ƒpublic class Test {
â€ƒâ€ƒâ€ƒâ€ƒpublic static void main(String[] args) {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒMap<MyClass, String> map = new HashMap<>();
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒMyClass k1 = new MyClass(1);
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒ
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒmap.put(k1, "A");
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒk1.id = 2;
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒ
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒSystem.out.println(map.get(new MyClass(1)));
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}
â€ƒâ€ƒ
-- null >>Â  After modifying k1.id, its hash changes, making the key untraceable.
-- Rule: Never modify an object after inserting it into a HashMap.

12. Whats the differenece between Fail-Fast and Fail-Safe
-- Fail-fast: Throws ConcurrentModificationException if modified during iteration. (e.g., ArrayList, HashMap).
-- Fail-safe: Works on a copy, allowing modifications (e.g., CopyOnWriteArrayList, ConcurrentHashMap).



13. Can A static method be overriden in Java?
â€ƒâ€ƒclass Parent {
â€ƒâ€ƒâ€ƒâ€ƒstatic void show() { System.out.println("Parent static method"); }
â€ƒâ€ƒ}
â€ƒâ€ƒÂ 
â€ƒâ€ƒclass Child extends Parent {
â€ƒâ€ƒâ€ƒâ€ƒstatic void show() { System.out.println("Child static method"); }
â€ƒâ€ƒ}
â€ƒâ€ƒÂ 
â€ƒâ€ƒpublic class StaticOverride {
â€ƒâ€ƒâ€ƒâ€ƒpublic static void main(String[] args) {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒParent obj = new Child();
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒobj.show();
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}
>> Ststic methods are not over ridden; they are hidden



14. What is covarinat return type?
--subclass method return type is same as that of super class method return type or sub class return type may be a subset of super class method return type.



15. What are exception handling rules in method overriding?
-- If superclass method does not declare an exception, subclass overridden method can not declare the checked exception but it can declare unchecked exception
-- If superclass method declares an exception, subclass overridden method can declare the same or subclass or no exception but it can not declare parent exception



16. Whats the diff b/w Final - Finally & Finalize
--Final: A keyword used to restrict modification of variables, methods, or classes
--Finally: A block used for cleanup code in exception handling
--Finalize: A method used by the garbage collector before an object is destroyed



â€ƒâ€ƒpublic class MyClass {
â€ƒâ€ƒâ€ƒâ€ƒint data = 10;
â€ƒâ€ƒâ€ƒâ€ƒpublic static void main(String[] args) {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒfinal MyClass myObj = new MyClass();
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒmyObj.data = 20;
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒSystem.out.println(myObj.data);
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}
-- 20



17. Why java main method is static?
-- It allows jvm to call main with out creating an object and there's no existing object initially, so it must be static to be called directly



18. What is Autoboxing?
-- The automatic convertion of primitive data type into its corresponding wrapper class



19. Can a class with a private constructor be instantiated?
-- Yes, but only within the class itself



20. Thread life cycle?
-- At any point of time, a java thread can lie in any one of the following states [NEW, RUNNABLE, RUNNING, WAITING, TERMINATED]



21. How many ways a thread can be created?
-- 1. Extending a thread class
-- 2. Implementing Runnable interface
-- 3. Using callable n Future task
-- 4. Using executor



22. Synchronized vs Volatile vs Transient Non Access Specifiers
-- Synchronized > Ensures that only one thread can execute a block/method at a time
-- Volatile > Ensures that the variable is always read from main memory, not from a threads local cache
-- Transient > Prevents a variable from being serialized



23. Whats happends when you swap @Service and @Repository?
-- both are specilizations of @component, so swappiung them wont break the functionality - but the exception transalation wont happen.





24. I have Employee class with varibales name, city and dept. Get a list of all employees who lives in Delhi City?
-- employees.stream().filter(e -> "Delhi".equalsIgnoreCase(e.getCity())).map(Employee::getName).collect(Collectors.toList);
-- orÂ 
-- Map<String, List<String> namesByCity = employees.stream.collect(Collectors.groupingBy(Employee::city, Collectors.mapping(Employee::getName, Collectors.toList())));
namesByCity.get("Delhi");



25. What is Optional in Java?
-- Optional is a container object used to avoid null references and prevent NullPointerException



26. Difference between Optional.of() and Optional.ofNullable()?
-- Optional.of() throws NullPointerException if the value is null
-- Optional.ofNullable() accepts null or non-null values

27.Â  What are the main components of a Stream?
-- Source â€“ e.g., Collection, array.
-- Intermediate Operations (Lazy, return a Stream)
â€ƒâ€ƒfilter(Predicate) â€“ Filters elements based on a condition.
â€ƒâ€ƒmap(Function) â€“ Transforms elements.
â€ƒâ€ƒflatMap(Function) â€“ Flattens nested structures.
â€ƒâ€ƒdistinct() â€“ Removes duplicate elements.
â€ƒâ€ƒsorted() â€“ Sorts elements.
â€ƒâ€ƒpeek(Consumer) â€“ Performs an action without modifying elements.
â€ƒâ€ƒlimit(long) â€“ Limits the number of elements.
â€ƒâ€ƒskip(long) â€“ Skips the first n elements.
-- Terminal Operations (Eager, return a result)
â€ƒâ€ƒforEach(Consumer) â€“ Processes each element.
â€ƒâ€ƒcollect(Collector) â€“ Converts stream into a collection.
â€ƒâ€ƒcount() â€“ Counts elements.
â€ƒâ€ƒreduce(BinaryOperator) â€“ Aggregates elements.
â€ƒâ€ƒanyMatch(Predicate) [Emptystream-> false], allMatch(Predicate) [Emptystream-> true], noneMatch(Predicate) [Emptystream-> true] â€“ Match operations.
â€ƒâ€ƒfindFirst(), findAny() â€“ Finds elements.
â€ƒâ€ƒtoArray() â€“ Converts stream into an array.
â€ƒâ€ƒmin(Comparator), max(Comparator) â€“ Finds minimum or maximum.
â€ƒâ€ƒsum(), average() â€“ Works with numeric streams.



28. what is the use of optional if Iwe can deal with null check?
-- Avoids NullPointerException â€“ Optional enforces handling of missing values explicitly, reducing the chances of unexpected NullPointerException.
-- Improves Readability â€“ It makes the code more readable and intentional. Instead of scattered null checks, you clearly indicate that a value might be absent.
-- Encourages Functional Programming â€“ Optional supports methods like map(), filter(), and ifPresent() to work with values in a more declarative way.
-- Provides Better API Design â€“ When returning values from methods, Optional<T> signals to consumers that the value might not be present, guiding them to handle the case properly.
-- Reduces Boilerplate Code â€“ Instead of multiple if checks and null assignments, Optional provides built-in methods like orElse(), orElseGet(), and orElseThrow() to handle default cases efficiently.



29. Stream vs ParallelStream?
-- Feature â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒstream() â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒparallelStream()
-- Execution â€ƒâ€ƒâ€ƒâ€ƒSingle-threaded â€ƒâ€ƒâ€ƒâ€ƒMulti-threaded (parallel)
-- Performance â€ƒâ€ƒâ€ƒâ€ƒPredictable â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒMay be faster with large data
-- Use Case â€ƒâ€ƒâ€ƒâ€ƒSmall-medium datasets â€ƒâ€ƒLarge datasets with CPU power



30.Â  Difference between map() and flatMap()?
-- map() â†’ transforms each element
eg. List<String> names = List.of("Alice", "Bob");
â€ƒâ€ƒList<Integer> lengths = names.stream()
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒ .map(String::length)
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒ .toList(); // [5, 3]
-- flatMap() â†’ flattens nested structures and then transforms
eg. List<List<String>> nestedList = List.of( List.of("a", "b"), List.of("c", "d"));
â€ƒâ€ƒList<String> flattenedList =Â  nestedList.stream()
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒ.flatMap(List::stream)
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒ.toList(); // ["a", "b", "c", "d"]



31. Difference between Loop and Stream?
-- Loop (Imperative Approach)
â€ƒâ€ƒ- Uses traditional constructs (for, while, do-while) to iterate through elements
â€ƒâ€ƒ- Explicitly defines each step in the iteration
â€ƒâ€ƒ- Requires manual handling of accumulation, filtering, and transformations
-- Stream (Declarative Approach)
â€ƒâ€ƒ- Uses functional programming concepts
â€ƒâ€ƒ- Provides built-in operations like map(), filter(), collect(), making code more concise
â€ƒâ€ƒ- Allows parallel processing (parallelStream())
â€ƒâ€ƒ- Improves readability and maintainability
â€ƒâ€ƒ
32. How do you reduce elements in a Stream?
-- Using reduce():
-- int sum = list.stream().reduce(0, Integer::sum);



33. Predicate, Function, Consumer, and BiConsumer are key functional interfaces with distinct purposes?
-Predicate<T>
â€ƒâ€ƒ- Represents a boolean-valued function
â€ƒâ€ƒ- Used for conditional checks (test() method)
 Â Â  eg. Predicate<Integer> isEven = num -> num % 2 == 0;
â€ƒâ€ƒâ€ƒâ€ƒSystem.out.println(isEven.test(4)); // true



-Function<T, R>
â€ƒâ€ƒ- Transforms an input (T) into an output (R)
â€ƒâ€ƒ- Used for mapping or conversions (apply() method)
â€ƒâ€ƒeg. Function<String, Integer> lengthFunction = str -> str.length();
â€ƒâ€ƒâ€ƒâ€ƒSystem.out.println(lengthFunction.apply("Hello")); // 5
â€ƒâ€ƒâ€ƒâ€ƒ
-Consumer<T>
â€ƒâ€ƒ- Accepts an input (T) but does not return a value
â€ƒâ€ƒ- Used for performing actions (accept() method)
â€ƒâ€ƒeg. Consumer<String> printConsumer = str -> System.out.println(str);
â€ƒâ€ƒâ€ƒâ€ƒprintConsumer.accept("Hello, World!"); // Prints "Hello, World!"
â€ƒâ€ƒâ€ƒâ€ƒ
-BiConsumer<T, U>
â€ƒâ€ƒ- Takes two inputs (T, U) without returning a value
â€ƒâ€ƒ- Used for actions that require two parameters (accept() method)
â€ƒâ€ƒeg. BiConsumer<String, Integer> printBiConsumer = (str, num) -> System.out.println(str + ": " + num);
â€ƒâ€ƒâ€ƒâ€ƒprintBiConsumer.accept("Score", 90); // Prints "Score: 90"
â€ƒâ€ƒ
34. What is a Functional Interface?
-- An interface with a single abstract method, can have default/static methods. Used in lambda expressions.

35. Can a Functional Interface extend another interface?
-- Yes, but it must not inherit more than one abstract method, or it wonâ€™t remain functional.

36. What is a Default Method in an Interface and why is it used?
-- A method with a body in an interface (using default keyword). Used to add new methods to interfaces without breaking implementing classes.

37.Â  What is a Method Reference?
-- A concise way to refer to methods:
-- list.forEach(System.out::println); // same as lambda s -> System.out.println(s)



38. What is Asynchronous Programming in Java?
-- Asynchronous (async) programming allows tasks to run in the background without blocking the main thread. Useful for I/O, API calls, and long-running tasks.



39. What is Future in Java?
-- Future in Java is part of the java.util.concurrent package and represents a result of an asynchronous computation. It helps in executing tasks in the background and retrieving the results when needed
-- You get the result later via future.get() (which blocks until done).
â€ƒâ€ƒeg. ExecutorService executor = Executors.newSingleThreadExecutor();
â€ƒâ€ƒâ€ƒâ€ƒFuture<Integer> future = executor.submit(() -> 10 + 5);
â€ƒâ€ƒâ€ƒâ€ƒSystem.out.println(future.get()); // blocks until result is ready
â€ƒâ€ƒâ€ƒâ€ƒexecutor.shutdown();
â€ƒâ€ƒâ€ƒâ€ƒ
40. What is CompletableFuture?Â 
-- CompletableFuture is an advanced feature in Javaâ€™s java.util.concurrent package for handling asynchronous programming. It extends Future but provides non-blocking operations, making it more powerful. It supports supports: Chaining (thenApply, thenAccept), Combining (thenCombine), Exception Handling (exceptionally, handle), Running multiple tasks in parallel
â€ƒâ€ƒeg. CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒreturn "Hello, World!";
â€ƒâ€ƒâ€ƒâ€ƒ});
â€ƒâ€ƒâ€ƒâ€ƒfuture.thenAccept(System.out::println); // Prints asynchronously
â€ƒâ€ƒâ€ƒâ€ƒ
â€ƒâ€ƒ- supplyAsync()â€ƒâ€ƒRuns a task asynchronously that returns a result.Â  
â€ƒâ€ƒ- thenApply()â€ƒâ€ƒTransforms the result.
â€ƒâ€ƒ- thenAccept()â€ƒâ€ƒConsumes the result.
â€ƒâ€ƒ- exceptionally()â€ƒâ€ƒHandles exceptions.
â€ƒâ€ƒ- thenCombine()â€ƒâ€ƒCombines two futures.

41. What is ExecutorService (Thread Pool)?
-- A thread pool manager used to execute async tasks. Avoids creating new threads for every task (better performance).
- ExecutorService executor = Executors.newFixedThreadPool(5);
â€ƒâ€ƒeg.
â€ƒâ€ƒexecutor.submit(() -> {
â€ƒâ€ƒâ€ƒâ€ƒSystem.out.println("Running task in background");
â€ƒâ€ƒ});
â€ƒâ€ƒexecutor.shutdown();
- newFixedThreadPool(n)â€ƒâ€ƒFixed number of threads.
- newCachedThreadPool()â€ƒâ€ƒCreates new threads as needed.
- newSingleThreadExecutor()â€ƒâ€ƒOne thread, tasks run sequentially.



42. Immutable Object Design Pattern?
- Declare the class as final â€“ Prevents inheritance and modifications.
- Make all fields private and final â€“ Prevents direct access and modification.
- Provide no setters â€“ Avoid modifying existing data.
- Initialize fields via constructor â€“ Assign values during object creation.
- Return defensive copies of mutable objects â€“ Prevent unintended modifications.



eg.
â€ƒâ€ƒpublic final class ImmutablePerson {
â€ƒâ€ƒâ€ƒâ€ƒprivate final String name;
â€ƒâ€ƒâ€ƒâ€ƒprivate final int age;



â€ƒâ€ƒâ€ƒâ€ƒpublic ImmutablePerson(String name, int age) {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒthis.name = name;
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒthis.age = age;
â€ƒâ€ƒâ€ƒâ€ƒ}



â€ƒâ€ƒâ€ƒâ€ƒpublic String getName() {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒreturn name;
â€ƒâ€ƒâ€ƒâ€ƒ}



â€ƒâ€ƒâ€ƒâ€ƒpublic int getAge() {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒreturn age;
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}
-- Handling Mutable Fields [If the class has mutable fields like List or Date, return a defensive copy]
eg.Â 
â€ƒâ€ƒpublic final class ImmutableData {
â€ƒâ€ƒâ€ƒâ€ƒprivate final List<String> items;



â€ƒâ€ƒâ€ƒâ€ƒpublic ImmutableData(List<String> items) {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒthis.items = new ArrayList<>(items); // Defensive copy
â€ƒâ€ƒâ€ƒâ€ƒ}



â€ƒâ€ƒâ€ƒâ€ƒpublic List<String> getItems() {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒreturn new ArrayList<>(items); // Defensive copy
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}



43. Factory Design Pattern?
-- The Factory Design Pattern is a creational pattern that provides a way to instantiate objects without exposing the instantiation logic. It creates objects based on given parameters, promoting loose coupling and flexibility.
eg.
â€ƒâ€ƒinterface Shape {
â€ƒâ€ƒâ€ƒâ€ƒvoid draw();
â€ƒâ€ƒ}



â€ƒâ€ƒclass Circle implements Shape {
â€ƒâ€ƒâ€ƒâ€ƒpublic void draw() {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒSystem.out.println("Drawing Circle");
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}



â€ƒâ€ƒclass Square implements Shape {
â€ƒâ€ƒâ€ƒâ€ƒpublic void draw() {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒSystem.out.println("Drawing Square");
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}



â€ƒâ€ƒclass ShapeFactory {
â€ƒâ€ƒâ€ƒâ€ƒpublic static Shape getShape(String type) {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒif ("CIRCLE".equalsIgnoreCase(type)) {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒreturn new Circle();
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒ} else if ("SQUARE".equalsIgnoreCase(type)) {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒreturn new Square();
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒreturn null;
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}



â€ƒâ€ƒ// Usage
â€ƒâ€ƒShape shape = ShapeFactory.getShape("CIRCLE");
â€ƒâ€ƒshape.draw(); // Drawing Circle



44. Singleton Design Pattern?
-- The Singleton Pattern ensures only one instance of a class exists globally and provides a single access point.
eg.
â€ƒâ€ƒpublic class Singleton {
â€ƒâ€ƒâ€ƒâ€ƒprivate static Singleton instance;



â€ƒâ€ƒâ€ƒâ€ƒprivate Singleton() {} // Private constructor



â€ƒâ€ƒâ€ƒâ€ƒpublic static Singleton getInstance() {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒif (instance == null) {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒinstance = new Singleton();
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒreturn instance;
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}



45. Inversion of Control (IoC) and Dependency Injection (DI)?
-- In Spring Boot, Inversion of Control (IoC) and Dependency Injection (DI) are fundamental concepts that allow the framework to manage object creation and dependencies efficiently.



46. Inversion of Control (IoC)?
-- IoC shifts the responsibility of managing dependencies from the application code to the Spring IoC Container. Instead of manually creating objects, Spring handles this through beans.



47. Dependency Injection (DI)?
-- DI is the technique used to implement IoC. Spring Boot injects dependencies automatically, avoiding tight coupling and improving maintainability.



48 Types of Dependency Injection in Spring Boot?
- Constructor Injection (Recommended) â€“ Dependencies are provided via constructor. [Best for immutability and testability, Cleaner code, no unnecessary annotations]
eg.Â 
â€ƒâ€ƒ@Service
â€ƒâ€ƒpublic class MyService {
â€ƒâ€ƒâ€ƒâ€ƒprivate final MyRepository repository;



â€ƒâ€ƒâ€ƒâ€ƒpublic MyService(MyRepository repository) {Â  // No @Autowired needed, explicit mention of @Autowired also fine not an issue
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒthis.repository = repository;
â€ƒâ€ƒâ€ƒâ€ƒ}



â€ƒâ€ƒâ€ƒâ€ƒpublic void execute() {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒrepository.process();
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}



- Setter Injection â€“ Dependencies are set through setter methods. [Used for optional dependencies, Allows modification- drawback, reducing immutability]
eg.
@Service
â€ƒâ€ƒpublic class MyService {
â€ƒâ€ƒâ€ƒâ€ƒprivate MyRepository repository;



â€ƒâ€ƒâ€ƒâ€ƒpublic void setRepository(MyRepository repository) { // Setter Injection // No @Autowired needed, explicit mention of @Autowired also fine not an issue
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒthis.repository = repository;
â€ƒâ€ƒâ€ƒâ€ƒ}



â€ƒâ€ƒâ€ƒâ€ƒpublic void execute() {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒrepository.process();
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}



- Field Injection â€“ Dependencies are injected directly into fields using annotations (@Autowired). [Not recommended due to tight coupling, Hard to mock in unit tests]
eg.
â€ƒâ€ƒ@Service
â€ƒâ€ƒpublic class MyService {
â€ƒâ€ƒâ€ƒâ€ƒprivate MyRepository repository; // No @Autowired needed, explicit mention of @Autowired also fine not an issue



â€ƒâ€ƒâ€ƒâ€ƒpublic MyService() {} // Default constructor



â€ƒâ€ƒâ€ƒâ€ƒpublic void execute() {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒrepository.process();
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}





49. Stereotype Annotations in Spring
-- Stereotype annotations in Spring are special meta-annotations used to define Spring-managed components (beans). They help in classifying components based on their roles in the application.
- @Component â†’ Marks a class as a Spring-managed bean.
- @Service / @Repository â†’ Specialized components for business logic and data access.
- @Autowired â†’ Injects dependencies automatically.
- @Qualifier â†’ Specifies which bean to inject when multiple options exist. [not a stero type one]
- @Configuration + @Bean â†’ Defines beans manually in Spring configuration.
- @Controller â†’ Specialized version of @Component for web controllers. Works with Spring MVC to handle requests.
- @RestController â†’ Combination of @Controller + @ResponseBody. Directly returns JSON responses instead of views.



50. Autowiring in Spring
-- Autowiring is a mechanism in Spring that automatically injects dependencies, eliminating the need for explicit bean wiring. It helps reduce boilerplate code and improves maintainability



- No Autowiring (Manual Injection)
â€ƒâ€ƒ. Dependencies are explicitly passed via configuration.
â€ƒâ€ƒ. Used when @Autowired is disabled.
â€ƒâ€ƒeg.
â€ƒâ€ƒ@Configuration
â€ƒâ€ƒpublic class AppConfig {
â€ƒâ€ƒâ€ƒâ€ƒ@Bean
â€ƒâ€ƒâ€ƒâ€ƒpublic MyRepository myRepository() {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒreturn new MyRepository();
â€ƒâ€ƒâ€ƒâ€ƒ}



â€ƒâ€ƒâ€ƒâ€ƒ@Bean
â€ƒâ€ƒâ€ƒâ€ƒpublic MyService myService() {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒreturn new MyService(myRepository()); // Manual injection
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}



- Autowiring by Name (byName)
â€ƒâ€ƒ. Spring matches bean name to the field/property name.
â€ƒâ€ƒ. Requires @Qualifier to specify the exact bean.
â€ƒâ€ƒeg.
â€ƒâ€ƒ@Service
â€ƒâ€ƒpublic class MyService {
â€ƒâ€ƒâ€ƒâ€ƒ@Autowired
â€ƒâ€ƒâ€ƒâ€ƒ@Qualifier("myRepository") // Matches bean name
â€ƒâ€ƒâ€ƒâ€ƒprivate MyRepository repository;
â€ƒâ€ƒ}



â€ƒâ€ƒ@Configuration
â€ƒâ€ƒpublic class AppConfig {
â€ƒâ€ƒâ€ƒâ€ƒ@Bean(name = "myRepository") // Defines bean name explicitly
â€ƒâ€ƒâ€ƒâ€ƒpublic MyRepository repository1() {
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒreturn new MyRepository();
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}



- Autowiring by Type (byType)
â€ƒâ€ƒ. Spring injects dependencies based on type.
â€ƒâ€ƒ. Works only when there is a single bean of that type.
â€ƒâ€ƒeg.
â€ƒâ€ƒ@Service
â€ƒâ€ƒpublic class MyService {
â€ƒâ€ƒâ€ƒâ€ƒ@Autowired // Injects based on type
â€ƒâ€ƒâ€ƒâ€ƒprivate MyRepository repository;
â€ƒâ€ƒ}



â€ƒâ€ƒ@Configuration
â€ƒâ€ƒpublic class AppConfig {
â€ƒâ€ƒâ€ƒâ€ƒ@Bean
â€ƒâ€ƒâ€ƒâ€ƒpublic MyRepository myRepository() { // Single bean of MyRepository type
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒreturn new MyRepository();
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}
â€ƒâ€ƒ
- Constructor Injection (constructor)
â€ƒâ€ƒ. Spring injects dependencies via the constructor.
â€ƒâ€ƒeg.
â€ƒâ€ƒ@Service
â€ƒâ€ƒpublic class MyService {
â€ƒâ€ƒâ€ƒâ€ƒprivate final MyRepository repository;



â€ƒâ€ƒâ€ƒâ€ƒ@Autowired
â€ƒâ€ƒâ€ƒâ€ƒpublic MyService(MyRepository repository) { // Constructor Injection
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒthis.repository = repository;
â€ƒâ€ƒâ€ƒâ€ƒ}
â€ƒâ€ƒ}



- Autodetect (autodetect) (Deprecated)
â€ƒâ€ƒ. Used to first try constructor injection, then fall back to byType.
â€ƒâ€ƒ. Removed in Spring 3.0, so not applicable in modern Spring Boot.
â€ƒâ€ƒ
>>âœ… Constructor Injection â†’ Recommended for cleaner, immutable design.Â 
>>âœ… By Type â†’ Works well for single bean types.Â 
>>âœ… By Name â†’ Use when multiple beans of the same type exist.Â 
>>âŒ Autodetect â†’ Deprecated, avoid using.



51. @Bean vs @Component?
-- @Component
â€ƒâ€ƒ- Used for automatic bean detection.
â€ƒâ€ƒ- Works with component scanning.
â€ƒâ€ƒ- Applied to class-level, turning the class into a Spring bean.
â€ƒâ€ƒ- Best for general components (services, repositories, controllers).
â€ƒâ€ƒ- âœ… Example: Using @Component (Auto-detected bean)



-- @Bean
â€ƒâ€ƒ- Used for manual bean definition in a Java configuration class (@Configuration).
â€ƒâ€ƒ- Allows creating custom beans, factory methods, or third-party integrations.
â€ƒâ€ƒ- Preferred when defining beans that are not part of the application package.
â€ƒâ€ƒ- âœ… Example: Using @Bean (Manual bean declaration)
â€ƒâ€ƒ
52. @Inject vs @Autowired in Spring Boot?
-- Both @Inject (from Jakarta/CDI) and @Autowired (from Spring) are used for dependency injection.
- @Autowired (Spring-Specific)
â€ƒâ€ƒ- Spring framework annotation for dependency injection.
â€ƒâ€ƒ- Supports optional dependencies via required=false.
â€ƒâ€ƒ- Allows qualifier-based injection (@Qualifier).
- @Inject (Jakarta/CDI Standard)
â€ƒâ€ƒ- Part of Jakarta EE / Java CDI, not Spring-specific.
â€ƒâ€ƒ- No required=false option (optional dependencies require manual handling).
â€ƒâ€ƒ- Works independently of Spring (can be used in non-Spring projects).
â€ƒâ€ƒ
53. ApplicationContext and BeanFactory?
-- Both are used for managing beans
- BeanFactory
â€ƒâ€ƒ- It is a basic, lightweight container for managing beans.
â€ƒâ€ƒ- Provides lazy initialization, meaning beans are created only when requested.
â€ƒâ€ƒ- Suitable for simple applications with minimal dependency management needs.
â€ƒâ€ƒ- Does not support automatic component scanning or annotations like @PostConstruct.
- ApplicationContext:
â€ƒâ€ƒ- It extends BeanFactory and provides advanced features.
â€ƒâ€ƒ- Supports eager initialization, meaning beans are created when the container starts.
â€ƒâ€ƒ- Has built-in support for AOP, event propagation, and internationalization.
â€ƒâ€ƒ- Can load properties and handle messaging.

54. Sealed Modifier [Improves security]?
-- Allows you to control which classes or interfaces can extend or implement a class/interface
eg. 
public sealed class Vehicle permits Car,Truck{} >> Restrics which classes can extend this class or implement the interface
public final class Car extends Vehicle{} >>  the class can not extend further
public non-sealed class Truck extends Vehicle{} >> non-sealed means open for extendion like normal classes

55. Record in Java?
-- It is a special class in Java used to model immutable data - like lightweight datacarrier or POJO with less Boilerplate
-- to simplify the creation of value clases - classes that just hold data (like DTO's)- by automaticallky generating constructor/getters/equals/hashcode,toString
eg.
public record Person(String anme, int age)
  === equals to ===
public final class person{
	private final String name;
	private final int age;

	// Public Constructor
	// Getters
	// hashCode
	// equals
	// toString

56. Improvement in Hashmap (Java 8)
-- performance enhancements under high concurrency and support for functional programming via streams and lambdas.
a. Faster in Case of Collisions
	-- When two keys in a HashMap go to the same bucket (i.e., hash collision), Java used to store them in a linked list.
	-- In Java 8, if there are many items (more than 8) in a single bucket, Java converts that list to a tree (Red-Black Tree).
	-- Trees are faster than lists, so searching becomes quicker â€” from slow (O(n)) to fast (O(log n)).
b. New Helpful Methods Added
	-- map.forEach((k, v) -> System.out.println(k + ": " + v));
	-- map.computeIfAbsent("key", k -> "default value");
	-- map.merge("key", 1, Integer::sum);

56. Hashmap internal working [internally stores data as an array of linked lists]
	1. A HashMap stores data as key-value pairs. [map.put("Apple", 10);] 
		-- it accepts one null keeey and multiple null values
		-- if key is null then it wont calculate haschcode() Java assigns hash as 0.
	2. Call hashCode() on the Key [int hash = "Apple".hashCode();  // might return something like 63062875]
	3. Hash Function (Hash Mixing > some extra operations on the hash to reduce collisions) [int h = key.hashCode(); int mixedHash = h ^ (h >>> 16);  // spreads the hash bits]
	4. Calculate Index in the Array (Bucket Index) >> HashMap uses an array internally. To decide where to store the key [index = mixedHash % arrayLength]

57. Arraylist vs LinkedList
| Feature / Operation                     | `ArrayList`                                         | `LinkedList`                                  |
| --------------------------------------- | --------------------------------------------------- | --------------------------------------------- |
| **Underlying Data Structure**           | Dynamic array (resizable array)                     | Doubly linked list                            |
| **Memory Usage**                        | Less (no pointers)                                  | More (extra memory for prev & next pointers)  |
| **Element Access (get(index))**         | âœ… Fast â†’ O(1) (direct index access)                | âŒ Slow â†’ O(n) (must traverse from head/tail) |
| **Insertion at End**                    | âœ… Fast â†’ O(1) (amortized; resizing may occur)      | âœ… Fast â†’ O(1)                                |
| **Insertion at Middle or Start**        | âŒ Slow â†’ O(n) (shifting elements)                  | âœ… Fast â†’ O(1) if node known, else O(n)       |
| **Removal from End**                    | âœ… Fast â†’ O(1)                                      | âœ… Fast â†’ O(1)                                |
| **Removal from Middle or Start**        | âŒ Slow â†’ O(n) (shifting elements)                  | âœ… Fast â†’ O(1) if node known, else O(n)       |
| **Search by Value (indexOf, contains)** | âŒ Slow â†’ O(n)                                      | âŒ Slow â†’ O(n)                                |
| **Iterator Performance**                | Faster (better cache locality)                      | Slower due to node traversal                  |
| **Reverse Traversal**                   | âŒ Not directly supported                           | âœ… Efficient (uses `previous` pointer)        |
| **Traversal (for loop)**                | âœ… Faster                                           | âŒ Slower                                     |

58. Treemap?
-- A TreeMap is a type of Map in Java that stores key-value pairs in a sorted order, based on the keys using a Red-Black Tree (self-balancing binary search tree)
-- No Null key is allowed but multiple null values allowed

59. Spring Bean Life Cycle?
	-- ðŸ­ Manufacture the machine â†’ (Object is created)
	-- ðŸ”Œ Plug it in â†’ (Inject power = dependencies)
	-- âš™ï¸ Initialize settings â†’ (Run init methods)
	-- âœ… Ready to work â†’ (Bean is active)
	-- ðŸ“´ Shutdown safely â†’ (Run destroy methods)

60. @Primary and @Qualifier
	-- when multiple beans of the same type, Spring doesnâ€™t know which one to inject
eg.
	@Component
	public class Dog implements Animal {}

	@Component
	public class Cat implements Animal {}
----
		@Component
		@Primary
		public class Dog implements Animal {}

		@Component
		public class Cat implements Animal {}
----
	@Autowired
	@Qualifier("cat")
	private Animal animal;

61. In how many ways an Object can be created in Java?
-- Using new Keyword >> MyClass obj = new MyClass();
-- Using Class.forName() and newInstance() >> MyClass obj = (MyClass) Class.forName("MyClass").newInstance();
-- Using Class.getDeclaredConstructor().newInstance() (Reflection) >> MyClass obj = MyClass.class.getDeclaredConstructor().newInstance();
-- Using clone() Method >> MyClass obj2 = (MyClass) obj1.clone();
-- Using Deserialization >> ObjectInputStream in = new ObjectInputStream(new FileInputStream("data.ser")); MyClass obj = (MyClass) in.readObject();
-- Using Factory Methods / Builders >> MyClass obj = MyClass.createInstance();
-- Using Constructor Reference (Java 8+) >> Supplier<MyClass> supplier = MyClass::new; MyClass obj = supplier.get();

62. Diff b/w ddep copy and shallow copy
-- A shallow copy creates a new object, but it copies references of the inner objects â€” not the actual objects. So, both the original and the copied object share the same inner objects
-- Deep Copy (Simple Definition): A deep copy creates a new object and also creates new copies of all inner objects. So, the original and the copied object are completely independent.

eg.
	class Address {
		String city;
	}

	class Person {
		String name;
		Address address;
	}
----- Shallow
		Person p1 = new Person();
		p1.name = "John";
		p1.address = new Address();
		p1.address.city = "Delhi";

		Person p2 = p1;  // Or use clone() if not deeply implemented

		p2.name = "Doe";
		p2.address.city = "Mumbai";

		System.out.println(p1.address.city); // ðŸ‘‰ Output: Mumbai (same object)
----- Deep
	Person p2 = new Person();
	p2.name = p1.name;
	p2.address = new Address();          // create new inner object
	p2.address.city = p1.address.city;   // copy values manually

63. Runnable vs callable?
	âœ… Runnable:
		Runnable is a Java interface used to run code in a thread.
		It does not return any result and cannot throw checked exceptions.
	-- public void run();  // No return, no checked exception

	âœ… Callable:
		Callable is like Runnable, but it can return a result and can throw checked exceptions.
	-- public V call() throws Exception;  // Returns a value, can throw exception

64. What is try-with-resources?
-- try-with-resources is a try block that automatically closes resources like files, streams, DB connections, etc., after use.
-- It was introduced in Java 7 to avoid manual closing of resources.

65. StringBuilder s1 = new StringBuilder("sas");
	StringBuilder s2 = new StringBuilder("sas");
	System.out.println(s1.equals(s2));  // false
-- StringBuilder does not override the equals() method from the Object class.
-- s1.equals(s2)  // same as  s1 == s2 (reference comparison)
-- Even though the contents ("sas") are the same, the references are different, so equals() returns false.

66. Map vs Flat Map
--map():
	- Transforms each element in the stream into another element.
	- The result is a Stream of transformed elements.
	- One-to-one mapping.
	eg. 
	List<String> names = List.of("Satya", "Ramya");

	List<Integer> lengths = names.stream()
		.map(String::length)
		.collect(Collectors.toList()); 	//Output: [5, 5] â€” A list of string lengths.
--flatMap():
	- Transforms each element into a stream (or a collection), and then flattens all those streams into a single stream.
	- One-to-many mapping.
	- Commonly used when each element might result in multiple elements.
	eg.
	List<String> sentences = List.of("I love Java", "Streams are powerful");
	List<String> words = sentences.stream()
		.flatMap(sentence -> Arrays.stream(sentence.split(" ")))
		.collect(Collectors.toList());	//Output: ["I", "love", "Java", "Streams", "are", "powerful"] â€” All words in a single flat list.


======================================================================================================
Databse
======================================================================================================



1. diff b/w delete drop n truncate
DELETE - removes specific rows from a table. Can have where condition & rollback is possible [SLOW Perf]
TRUNCATE - Removes all rows from a table but keps the structure [FASTER perf]
DROP - Deletes the entire table (structure + data) [FASTEST perf]



S1. You have an employees table with columns: id, name, age, salary, email and department. Write a query to fetch employees from the IT department earning more than 50,000.
-- SELECT * FROM employee WHERE department = 'IT' AND salary > 50000;



s2. Ensure that the salary column in the employees table does not allow negative values
-- ALTER TABLE employees ADD CONSTRAINT chk_salary CHECK (salary >= 0);



S3. Find all duplicate emails and their count from the employees table.
-- SELECT email, COUNT(*) AS total FROM employee GROUP BY email HAVING COUNT(*) > 1;



s4. Find the second highest salary from the employees table.
-- SELECT DISTINCT salary FROM employee ORDER BY salary DESC LIMIT 1 OFFSET 1;



s5. Find employees who do not belong to any department.
-- SELECT e.name FROM employees e LEFT JOIN departments d ON e.dept_id = d.dept_id WHERE d.dept_id IS NULL;



s6. You have two tables: employees (id, name, dept_id) & departments (dept_id, dept_name)
Write a query to fetch all employees along with their department names.
-- SELECT e.name, d.dept_name FROM employees e JOIN departments d ON e.dept_id = d.dept_id;



s7. Delete all employees who have resigned before 2020-01-01 from resigned_employees table.
-- DELETE FROM resigned_employees WHERE resign_date < '2020-01-01';



s8. You deleted all records from the orders table but the auto-increment is still increasing. Reset it.
-- TRUNCATE TABLE orders;



s9. You have a products table with millions of records. Searching by product_name is slow. How do you optimize it?
-- CREATE INDEX idx_product_name ON products(product_name);
